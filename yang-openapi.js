// Generated by CoffeeScript 1.11.1
(function() {
  var Yang, debug, definitions, discoverOperations, discoverPaths, yaml, yang2jschema, yang2jsobj, yang2jstype;

  if (process.env.DEBUG != null) {
    debug = require('debug')('yang:openapi');
  }

  Yang = require('yang-js');

  yaml = require('js-yaml');

  definitions = {};

  yang2jstype = function(schema) {
    var datatype, jschema, k, ref, ref1, v;
    jschema = {
      description: (ref = schema.description) != null ? ref.tag : void 0,
      "default": (ref1 = schema["default"]) != null ? ref1.tag : void 0
    };
    if (schema.type == null) {
      return jschema;
    }
    datatype = (function() {
      switch (schema.type.primitive) {
        case 'uint8':
        case 'int8':
          return {
            type: 'integer',
            format: 'byte'
          };
        case 'uint16':
        case 'uint32':
        case 'uint64':
        case 'int16':
        case 'int32':
        case 'int64':
          return {
            type: 'integer',
            format: schema.type.primitive
          };
        case 'binary':
          return {
            type: 'string',
            format: 'binary'
          };
        case 'decimal64':
          return {
            type: 'number',
            format: 'double'
          };
        case 'union':
          return {
            anyOf: []
          };
        case 'boolean':
          return {
            type: 'boolean',
            format: schema.type.tag
          };
        case 'enumeration':
          return {
            type: 'string',
            format: schema.type.tag,
            "enum": schema.type["enum"].map(function(e) {
              return e.tag;
            })
          };
        default:
          return {
            type: 'string',
            format: schema.type.tag
          };
      }
    })();
    for (k in datatype) {
      v = datatype[k];
      jschema[k] = v;
    }
    return jschema;
  };

  yang2jsobj = function(schema) {
    var property, ref, ref1, required;
    required = [];
    property = schema.nodes.filter(function(x) {
      return x.parent === schema;
    }).map(function(node) {
      var ref;
      if (((ref = node.mandatory) != null ? ref.valueOf() : void 0) === true) {
        required.push(node.tag);
      }
      return {
        name: node.tag,
        schema: yang2jschema(node)
      };
    });
    if (schema.uses != null) {
      return {
        description: (ref = schema.description) != null ? ref.tag : void 0,
        allOf: schema.uses.map(function(x) {
          definitions[x.tag] = yang2jschema(x.grouping);
          return {
            '$ref': "#/definitions/" + x.tag
          };
        }).concat({
          required: required.length ? required : void 0,
          property: property.length ? property : void 0
        })
      };
    } else {
      return {
        type: 'object',
        description: (ref1 = schema.description) != null ? ref1.tag : void 0,
        required: required.length ? required : void 0,
        property: property.length ? property : void 0
      };
    }
  };

  yang2jschema = function(schema, collection) {
    if (collection == null) {
      collection = false;
    }
    if (schema == null) {
      return {};
    }
    switch (schema.kind) {
      case 'leaf':
        return yang2jstype(schema);
      case 'leaf-list':
        return {
          type: 'array',
          items: yang2jstype(schema)
        };
      case 'container':
        return yang2jsobj(schema);
      case 'list':
        if (collection) {
          return {
            type: 'array',
            items: yang2jsobj(schema)
          };
        } else {
          return yang2jsobj(schema);
        }
        break;
      default:
        return {};
    }
  };

  discoverOperations = function(schema, item) {
    var deprecated, ref;
    if (item == null) {
      item = false;
    }
    if (typeof debug === "function") {
      debug("discover operations for " + schema.trail);
    }
    deprecated = ((ref = schema.status) != null ? ref.valueOf() : void 0) === 'deprecated';
    switch (false) {
      case schema.kind !== 'rpc':
        return [
          {
            method: 'post',
            summary: "Invokes " + schema.tag + " in " + schema.parent.tag + ".",
            deprecated: deprecated,
            response: [
              {
                code: 200,
                schema: yang2jschema(schema.output)
              }
            ]
          }
        ];
      case !(schema.kind === 'list' && !item):
        return [
          {
            method: 'post',
            summary: "Creates one or more new " + schema.tag + " in " + schema.parent.tag + ".",
            deprecated: deprecated,
            response: [
              {
                code: 200,
                description: "Expected response for creating " + schema.tag + "(s) in collection",
                schema: yang2jschema(schema, true)
              }
            ]
          }, {
            method: 'get',
            description: schema.description,
            summary: "List all " + schema.tag + "s from " + schema.parent.tag,
            deprecated: deprecated,
            response: [
              {
                code: 200,
                description: "Expected response of " + schema.tag + "s",
                schema: yang2jschema(schema, true)
              }
            ]
          }, {
            method: 'put',
            summary: "Replace the entire " + schema.tag + " collection",
            deprecated: deprecated,
            response: [
              {
                code: 201,
                description: "Expected response for replacing collection"
              }
            ]
          }, {
            method: 'patch',
            summary: "Merge items into the " + schema.tag + " collection",
            deprecated: deprecated,
            response: [
              {
                code: 201,
                description: "Expected response for merging into collection"
              }
            ]
          }
        ];
      default:
        return [
          {
            method: 'get',
            description: schema.description,
            summary: "View detail on " + schema.tag,
            deprecated: deprecated,
            response: [
              {
                code: 200,
                description: "Expected response of " + schema.tag,
                schema: yang2jschema(schema)
              }
            ]
          }, {
            method: 'put',
            summary: "Update details on " + schema.tag,
            deprecated: deprecated,
            response: [
              {
                code: 200,
                description: "Expected response of " + schema.tag,
                schema: yang2jschema(schema)
              }
            ]
          }, {
            method: 'patch',
            summary: "Merge details on " + schema.tag,
            deprecated: deprecated,
            response: [
              {
                code: 200,
                description: "Expected response of " + schema.tag,
                schema: yang2jschema(schema)
              }
            ]
          }, {
            method: 'delete',
            summary: "Deletes a " + schema.tag + " from " + schema.parent.tag + ".",
            deprecated: deprecated,
            response: [
              {
                code: 204,
                description: "Expected response for delete"
              }
            ]
          }
        ];
    }
  };

  discoverPaths = function(schema) {
    var key, name, paths, ref, ref1, ref2, sub, subpaths;
    if ((ref = schema.kind) !== 'list' && ref !== 'container' && ref !== 'rpc') {
      return [];
    }
    name = "/" + schema.datakey;
    if (typeof debug === "function") {
      debug("discover paths for " + name);
    }
    paths = [
      {
        name: name,
        operation: discoverOperations(schema)
      }
    ];
    subpaths = (function() {
      var i, len, ref1, results;
      ref1 = schema.nodes;
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        sub = ref1[i];
        results.push(discoverPaths(sub));
      }
      return results;
    })();
    switch (schema.kind) {
      case 'list':
        key = (ref1 = (ref2 = schema.key) != null ? ref2.valueOf() : void 0) != null ? ref1 : 'id';
        paths.push({
          name: name + "/{" + key + "}",
          operations: discoverOperations(schema, true)
        });
        subpaths.forEach(function(x) {
          return x.name = (name + "/{" + key + "}") + x.name;
        });
        break;
      case 'container':
        subpaths.forEach(function(x) {
          return x.name = name + x.name;
        });
    }
    if (typeof debug === "function") {
      debug("discovered " + paths.length + " paths with " + subpaths.length + " subpaths");
    }
    return paths.concat.apply(paths, subpaths);
  };

  module.exports = require('./yang-openapi.yang').bind({
    transform: function() {
      var k, modules, v;
      modules = this.input.modules.map((function(_this) {
        return function(name) {
          return _this.schema.constructor["import"](name);
        };
      })(this));
      definitions = {};
      return this.output = {
        info: this.get('/info'),
        consumes: ["application/json"],
        produces: ["application/json"],
        path: modules.map(function(m) {
          var i, len, ref, results, schema;
          ref = m.nodes;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            schema = ref[i];
            results.push(discoverPaths(schema));
          }
          return results;
        }).reduce((function(a, b) {
          return a.concat(b);
        }), []),
        definition: (function() {
          var results;
          results = [];
          for (k in definitions) {
            v = definitions[k];
            results.push({
              name: k,
              schema: v
            });
          }
          return results;
        })()
      };
    }
  });

}).call(this);
